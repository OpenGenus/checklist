<!DOCTYPE html>
<!--
GNU General Public License v3.0
OpenGenus IQ  -- iq.opengenus.org
team@opengenus.org
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Graph Algorithms Checklist: 13 weeks free course</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <meta
      property="og:site_name"
      content="OpenGenus IQ: Computing Expertise &amp; Legacy"
    />
    <meta property="og:type" content="article, checklist" />
    <meta property="og:title" content="Data Science Checklist" />
    <meta
      property="og:description"
      content="This is a short guide helping you to understand how to use our Checklists to keep track of your progress daily."
    />
    <meta
      property="og:image"
      content="https://iq.opengenus.org/content/images/2022/05/checklist.jpg"
    />
    <meta property="article:modified_time" content="2022-05-28T13:12:13.000Z" />
    <meta property="article:tag" content="checklist" />
    <meta
      property="article:publisher"
      content="https://www.facebook.com/opengenus"
    />
    <meta
      property="article:author"
      content="https://www.facebook.com/opengenus"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Data Science Checklist" />
    <meta name="twitter:description" content="Data Science Checklist" />
    <meta
      name="twitter:image"
      content="https://iq.opengenus.org/content/images/2022/05/checklist.jpg"
    />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="checklist" />
    <meta name="twitter:site" content="@OpenGenus" />
    <meta name="twitter:creator" content="@opengenus" />
    <meta property="og:image:width" content="918" />
    <meta property="og:image:height" content="563" />
    <link rel="stylesheet" href="./assets/css/checklist/checklist-style.css" />
  </head>
  <body>
    <script type="text/javascript">
      var code = "4";
    </script>

    <header>
      <h1 class="title">Graph Algorithms Checklist: 13 weeks free course</h1>
      <p class="text_small">
        Powered by OpenGenus IQ because we want you ❤️ to succeed. (<a
          href="https://iq.opengenus.org/use-checklist/"
          target="_blank"
          rel="noopener"
          >How to use this?</a
        >)<br />Bookmark this page now (press <code>CTRL</code> +
        <code>D</code>) to easily use this masterpiece tomorrow<br />
      </p>
      <p class="text_small">
        Only concepts that you need to review to master Graph algorithms
      </p>
      <div class="progress">
        <span class="progress__count">0/X</span>
        <input
          class="progress__reset"
          type="reset"
          value="Reset"
          title="Reset Checkboxes"
          tabindex="0"
        />
        <span class="progress__border"></span>
        <span class="progress__bar"></span>
      </div>
    </header>

    <div class="container">
      <section class="checklist">
        <h2 class="checklist__title">Week 1: Graph Algorithm Basics</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Graph Representation: Adjacency Matrix & Adjacency List</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/graph-representation-adjacency-matrix-adjacency-list/"
                  target="_blank"
                  rel="noopener"
                  >Graph Representation: Adjacency Matrix & Adjacency List</a
                >
                is a technique used to represent graphs in computer science,
                where an
                <a
                  href="https://iq.opengenus.org/adjacency-matrix/"
                  target="_blank"
                  rel="noopener"
                  >adjacency matrix </a
                >is a square matrix used to represent a finite graph, and an
                adjacency list is a collection of unordered lists used to
                represent a finite graph.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Directed Graph vs Undirected Graph</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/directed-vs-undirected-graph/"
                  target="_blank"
                  rel="noopener"
                  >Directed Graph vs Undirected Graph</a
                >
                explains the difference between these two types of graphs and
                how they can be represented mathematically.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Depth First Search</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/depth-first-search/"
                  target="_blank"
                  rel="noopener"
                  >Depth-First Search</a
                >
                is an algorithm used to traverse a graph or tree in which the
                search moves down a branch as far as possible.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Breadth First Search</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/breadth-first-search/"
                  target="_blank"
                  rel="noopener"
                  >Breadth-First Search</a
                >
                (BFS) is an algorithm used to traverse a graph or tree in which
                the search visits all the vertices at the same level before
                moving down to the next level.
                <a
                  href="https://iq.opengenus.org/bfs-graph-traversal/"
                  target="_blank"
                  rel="noopener"
                  >BFS</a
                >
                is also a popular algorithm used to find shortest paths between
                nodes.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Depth First Search vs Breadth First Search
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/dfs-vs-bfs/"
                  target="_blank"
                  rel="noopener"
                  >Depth First Search vs Breadth First Search</a
                >
                is a comparison of two traversal algorithms used in graph
                theory.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Bidirectional Search Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/bidirectional-search/"
                  target="_blank"
                  rel="noopener"
                  >Bidirectional Search Algorithm</a
                >
                is a graph traversal algorithm that searches for a path between
                two nodes in a graph by simultaneously running two breadth-first
                searches, one from the start node and one from the end node,
                until the two searches meet in the middle.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 2: Topological Sorting</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Topological Sort (BFS)</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/topological-sort-bfs/"
                  target="_blank"
                  rel="noopener"
                  >Topological Sort using BFS</a
                >
                works by initially finding all the nodes in the graph with zero
                incoming edges and adding them to a queue. Then it repeatedly
                removes the first node from the queue, adds it to the
                topologically sorted list, and removes all of its outgoing
                edges. If any nodes have zero incoming edges as a result of this
                removal, they are added to the queue. This process continues
                until the queue is empty and all nodes have been added to the
                topologically sorted list.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Topological Sorting (DFS)</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to perform
                <a
                  href="https://iq.opengenus.org/topological-sorting-dfs/"
                  target="_blank"
                  rel="noopener"
                  >Topological Sorting using DFS</a
                >. The algorithm works by recursively visiting each node in the
                graph using DFS and keeping track of a list of nodes in the
                order in which they finish being visited.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Kahn's Algorithm for Topological Sorting</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/kahns-algorithm-topological-sort/"
                  target="_blank"
                  rel="noopener"
                  >Kahn's algorithm for topological sorting</a
                >
                works by initially finding nodes in the graph with zero incoming
                edges, removing them and their outgoing edges from the graph,
                and repeating the process with the updated graph. This continues
                until all nodes have been removed and the algorithm outputs the
                nodes in the order in which they were removed.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Applications of Topological Sort</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/applications-of-topological-sort/"
                  target="_blank"
                  rel="noopener"
                  >Applications of Topological Sort</a
                >
                discusses various real-world applications of topological
                sorting. It provides examples of how the technique can be used
                in areas such as project scheduling, build systems, and task
                management. Additionally, it discusses the benefits of using
                topological sorting in these contexts, such as improved
                efficiency and reduced errors.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 3: Shortest Path in Graph</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Shortest path using topological sort</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/shortest-path-using-topological-sort/"
                  target="_blank"
                  rel="noopener"
                  >Shortest path using topological sort</a
                >
                article explains an algorithm to find the shortest path between
                two vertices in a directed acyclic graph (DAG), using a
                topological sorting technique and dynamic programming.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Counting Paths in a Matrix</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/count-paths-from-top-left-to-bottom-right-of-a-matrix/"
                  target="_blank"
                  rel="noopener"
                  >Counting Paths in a Matrix</a
                >
                is a dynamic programming algorithm that counts the number of
                unique paths from the top left corner to the bottom right corner
                of a matrix, moving only right or down, by computing a table of
                intermediate counts for each position in the matrix and using
                this table to gradually update the total count. In the context
                of matrices, intermediate counts refer to the number of elements
                that are present between two specific elements in a matrix.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Print all the paths between two vertices</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/print-all-the-paths-between-two-vertices/"
                  target="_blank"
                  rel="noopener"
                  >Print all the paths between two vertices</a
                >
                article explains how to find and print all possible paths
                between two vertices in a graph, including paths that pass
                through other vertices, using Depth First Search(DFS) and
                backtracking.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Shortest path with k edges</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to find the
                <a
                  href="https://iq.opengenus.org/shortest-path-with-k-edges/"
                  target="_blank"
                  rel="noopener"
                  >shortest path with k edges</a
                >
                using an algorithm to find the shortest path between two
                vertices in a graph, with a constraint that the path must have a
                fixed number of edges, using dynamic programming.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Path between nodes in a directed graph</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/path-between-nodes-directed-graph/"
                  target="_blank"
                  rel="noopener"
                  >Path between nodes in a directed graph</a
                >
                article explains a recursive graph traversal algorithm used to
                find all possible paths between two nodes in a directed graph
                using DFS.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Dijkstra's Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/dijkstras-algorithm-finding-shortest-path-between-all-nodes/"
                  target="_blank"
                  rel="noopener"
                  >Dijkstra's Algorithm</a
                >
                is a pathfinding algorithm that finds the shortest path between
                a starting node and all other nodes in a weighted graph, using a
                priority queue to efficiently explore the graph and update the
                distances to each node. Also learn about the algorithm's
                <a
                  href="https://iq.opengenus.org/time-and-space-complexity-of-dijkstra-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >time and space complexity</a
                >.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Shortest Path Faster Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/shortest-path-faster-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Shortest Path Faster Algorithm</a
                >
                is an improvement on Dijkstra's algorithm for finding the
                shortest path in a weighted graph that allows negative edge
                weights. It uses a queue-based approach to efficiently explore
                the graph and update the distances to each node.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Floyd-Warshall Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/floyd-warshall-algorithm-shortest-path-between-all-pair-of-nodes/"
                  target="_blank"
                  rel="noopener"
                  >Floyd-Warshall Algorithm</a
                >
                is a dynamic programming algorithm that finds the shortest path
                between all pairs of nodes in a weighted graph, by computing a
                table of intermediate distances between all pairs of nodes and
                using this table to gradually update the shortest path.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Bellman-Ford Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/bellman-ford-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Bellman-Ford Algorithm</a
                >
                is an algorithm for finding the shortest path between a starting
                node and all other nodes in a weighted graph, even when the
                graph has negative edge weights. It works by iteratively
                relaxing the edges of the graph to gradually find the shortest
                path. In addition, also understand
                <a
                  href="https://iq.opengenus.org/time-and-space-complexity-of-bellman-ford-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >the time and space complexity of the algorithm</a
                >.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Johnson Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/johnson-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Johnson Algorithm</a
                >
                is an algorithm for finding the shortest path between all pairs
                of nodes in a weighted graph. It works by first reweighting the
                edges of the graph using a potential function, and then using
                Dijkstra's algorithm to find the shortest path between each pair
                of nodes.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">DeSopo-Pape algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/desopo-pape-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >DeSopo-Pape algorithm</a
                >
                article explains a single-source shortest path algorithm that
                handles negative edge weights by using a stack and a priority
                queue, and can work on both directed and undirected graphs. It
                is an improvement over Dijkstra's algorithm.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 4: Minimum Spanning Tree</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Introduction to Minimum Spanning Trees</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/what-is-a-minimum-spanning-tree/"
                  target="_blank"
                  rel="noopener"
                  >Minimum Spanning Tree</a
                >
                is a tree that spans all the vertices of a connected, weighted
                graph with the least possible total edge weight.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Kruskal's Minimum Spanning Tree Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/kruskal-minimum-spanning-tree-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Kruskal's Minimum Spanning Tree Algorithm</a
                >
                involves sorting the edges by weight and adding them one by one
                to the tree as long as they don't create a cycle. Also analyse
                the
                <a
                  href="https://iq.opengenus.org/time-and-space-complexity-of-kruskal-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >time and space complexity of the algorithm</a
                >.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Prim's Minimum Spanning Tree Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/prim-minimum-spanning-tree-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Prim's Minimum Spanning Tree Algorithm</a
                >
                involves starting with an arbitrary vertex and adding the edge
                with the smallest weight to the growing tree until all vertices
                are included. Additionally, learn about the algorithm's
                <a
                  href="https://iq.opengenus.org/time-and-space-complexity-of-prims-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >time and space complexity</a
                >.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Boruvka's Minimum Spanning Tree Algorithm
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/boruvka-minimum-spanning-tree/"
                  target="_blank"
                  rel="noopener"
                  >Boruvka's Minimum Spanning Tree Algorithm</a
                >
                involves creating a forest of trees where each tree is a single
                vertex, and then repeatedly adding the cheapest edge that
                connects two different trees until all vertices are in a single
                tree.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Reverse Delete Algorithm
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/reverse-delete-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Reverse Delete Algorithm</a
                >
                involves starting with all edges in a graph and removing them
                one by one in non-increasing order of weight until the remaining
                edges form a tree.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 5: Maximum Flow Problem</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Introduction to Maximum Flow Problem</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/maximum-flow-problem-overview/"
                  target="_blank"
                  rel="noopener"
                  >Maximum Flow Problem</a
                >
                involves finding the maximum flow that can be sent through a
                network from a source to a sink. Here, the term "flow" refers to
                some quantity, such as data, that is being transported through a
                network represented as a directed graph. Solving the maximum
                flow problem has many real-world applications, such as
                optimizing transportation networks, managing internet traffic,
                and designing water distribution systems.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Ford-Fulkerson Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/ford-fulkerson-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Ford-Fulkerson Algorithm</a
                >
                is based on the concept of augmenting paths and works by
                iteratively finding augmenting paths from the source to the sink
                until no more paths can be found. This algorithm makes use of
                Depth First Search (DFS). In a flow network, an augmenting path
                is a path that can be used to increase the amount of flow that
                can be sent from the source to the sink.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Dinic's Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/dinics-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Dinic's Algorithm</a
                >
                is based on the concept of layered graphs and works by
                iteratively building a layered graph and finding blocking flows
                until no more blocking flows can be found. A layered graph is a
                type of graph where the nodes are partitioned into layers, with
                each layer representing a different distance from the source. In
                other words, nodes in the same layer are at the same distance
                from the source.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Edmonds-Karp Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/edmonds-karp-algorithm-for-maximum-flow/"
                  target="_blank"
                  rel="noopener"
                  >Edmonds-Karp Algorithm for Maximum Flow</a
                >
                uses a breadth-first search to find augmenting paths and then
                calculates the maximum amount of flow that can be sent from the
                source to the sink.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Push-Relabel Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/push-relabel-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Push-Relabel Algorithm</a
                >
                works by maintaining a preflow, which is a partial flow that
                satisfies certain conditions, and then iteratively pushing flow
                from nodes with excess flow to nodes with deficit flow.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 6: Graph Coloring Problem</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Overview of Graph Colouring Algorithms</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/overview-of-graph-colouring-algorithms/"
                  target="_blank"
                  rel="noopener"
                  >Graph Colouring Algorithms</a
                >
                involve assigning colors to the vertices of a graph such that
                adjacent vertices do not have the same color.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Bipartite Checking using BFS</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn about
                <a
                  href="https://iq.opengenus.org/bipartite-checking-bfs/"
                  target="_blank"
                  rel="noopener"
                  >Bipartite Checking using BFS</a
                >. A graph is bipartite if it is possible to divide its vertices
                into two independent sets such that every edge connects a vertex
                from one set to a vertex from the other set. We use Breadth
                First Search (BFS) to color the vertices of the graph in two
                colors, starting from an arbitrary vertex. If, during this
                process, an edge is found that connects two vertices of the same
                color, then the graph is not bipartite. If all edges can be
                colored without any conflicts, then the graph is bipartite.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Graph Colouring using Greedy Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/graph-colouring-greedy-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Graph Colouring using Greedy Algorithm</a
                >
                is a widely used algorithm for graph coloring that assigns
                colors to vertices in a way that minimizes the total number of
                colors used.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">
              Wigderson Algorithm for Graph Coloring
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/wigderson-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Wigderson algorithm</a
                >
                is a randomized algorithm for coloring graphs. The algorithm
                works by randomly partitioning the vertices of the graph into
                subsets, and then recursively coloring each subset using a
                reduced color palette.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Welsh-Powell Algorithm </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/welsh-powell-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Welsh-Powell Algorithm for Graph Coloring</a
                >
                is a simple heuristic algorithm used to color graphs that sorts
                the vertices in decreasing order of degree and assigns colors to
                each vertex, making sure that no adjacent vertices have the same
                color.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Flood Fill Algorithms </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Explore the
                <a
                  href="https://iq.opengenus.org/flood-fill-algorithms/"
                  target="_blank"
                  rel="noopener"
                  >flood fill algorithm</a
                >, a technique used to fill a connected region of pixels with a
                particular color.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 7: Maximum Matching Problem</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Introduction to Maximum Matching</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/maximum-matching/"
                  target="_blank"
                  rel="noopener"
                  >Maximum matching</a
                >
                is a graph theory problem that involves finding the largest set
                of edges in a graph such that no two edges share a common
                vertex. It has applications in fields such as computer
                networking, image processing, and social network analysis.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">
              Hungarian Maximum Matching Algorithm
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/hungarian-maximum-matching-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >The Hungarian algorithm</a
                >
                is a well-known algorithm for solving the maximum matching
                problem in bipartite graphs. It works by augmenting the matching
                until no further improvement is possible.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Hopcroft-Karp Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/hopcroft-karp-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >The Hopcroft-Karp algorithm</a
                >
                is an efficient algorithm for finding the maximum matching in a
                bipartite graph. It works by alternating between finding
                augmenting paths and updating the matching, and has been used in
                applications such as online advertising and recommendation
                systems.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Blossom Maximum Matching Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/blossom-maximum-matching-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >The Blossom algorithm</a
                >
                is a graph theory algorithm for finding maximum matchings in
                general graphs. It works by finding augmenting paths in a way
                that reduces the size of the graph, and has applications in
                areas such as transportation and supply chain management.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 7: Stable Marriage Problem</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Stable Matching and Gale-Shapley algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/basics-of-stable-matching/"
                  target="_blank"
                  rel="noopener"
                  >Stable matching</a
                >
                is a problem in which two groups of individuals have preferences
                for members of the other group, and the goal is to find a stable
                pairing of individuals such that no two individuals prefer each
                other to their current partners. Also learn about the
                <a
                  href="https://iq.opengenus.org/gale-shapley-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Gale-Shapley algorithm</a
                >, which is a popular algorithm for solving this problem.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">
              Variants of Stable Matching
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/variants-of-stable-matching/"
                  target="_blank"
                  rel="noopener"
                  >Variants of stable matching</a
                >
                are modifications to the original stable matching problem that
                involve additional constraints or objectives. This article
                discusses two common variants: incomplete preference lists, in
                which some individuals do not have preferences for all members
                of the other group, and weighted preferences, in which
                individuals have numerical rankings of their preferences that
                are used to compute a weighted stability score for each pairing.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 8: Maximum / Minimum Cut Problems</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Maximum Cut Problem</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/maximum-cut-problem/"
                  target="_blank"
                  rel="noopener"
                  >Maximum Cut Problem</a
                >
                article discusses the maximum cut problem in graph theory, which
                involves dividing the nodes of a graph into two disjoint sets
                with the maximum number of edges between them.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Minimum Cut Problem </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/minimum-cut-problem/"
                  target="_blank"
                  rel="noopener"
                  >Minimum Cut Problem</a
                >
                article explains the minimum cut problem in graph theory, which
                involves finding the smallest cut in a graph that divides the
                nodes into two disjoint sets.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Articulation Points or Cut Vertices in a Graph
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Understand how to find<a
                  href="https://iq.opengenus.org/find-articulation-points-or-cut-vertices-in-a-graph/"
                  target="_blank"
                  rel="noopener"
                >
                  articulation points or cut vertices in a graph</a
                >. In a graph, connected components are groups of vertices that
                are connected to each other by edges.
                <a
                  href="https://iq.opengenus.org/find-articulation-point-in-graph/"
                  target="_blank"
                  rel="noopener"
                  >Articulation points</a
                >
                are the vertices in a graph that, if removed, would increase the
                number of connected components in the graph. If you remove this
                vertex, the graph might split into multiple smaller pieces, and
                each piece would become a connected component on its own.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Cut Edges in a Graph</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/find-cut-edges-in-a-graph/"
                  target="_blank"
                  rel="noopener"
                  >find cut edges in a graph</a
                >
                and how to identify them. Cut edges are the edges in a graph
                that, if removed, would increase the number of connected
                components in the graph.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Karger Algorithm </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/karger-algorithm-to-find-minimum-cut/"
                  target="_blank"
                  rel="noopener"
                  >Karger Algorithm to Find Minimum Cut</a
                >
                is a randomized algorithm used to find the minimum cut in a
                graph. The algorithm works by iteratively contracting two
                randomly chosen vertices until only two vertices are left. The
                cut that corresponds to these two vertices is the minimum cut of
                the original graph.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 8: Strongly Connected Components</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Euler or Eulerian Tour</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/what-is-a-euler-or-eulerian-tour/"
                  target="_blank"
                  rel="noopener"
                  >Euler or Eulerian Tour</a
                >
                is a path that visits every edge exactly once. Euler tour can be
                found in both directed and undirected graphs.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Tarjan's Algorithm </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/tarjans-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Tarjan's Algorithm</a
                >
                is a graph traversal algorithm used to find strongly connected
                components in a directed graph. It uses a stack-based approach
                and a recursive depth-first search.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Kosaraju's Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/kosarajus-algorithm-for-strongly-connected-components/"
                  target="_blank"
                  rel="noopener"
                  >Kosaraju's Algorithm for Strongly Connected Components</a
                >
                is an algorithm used to find strongly connected components in a
                directed graph. It uses two depth-first searches and a
                stack-based approach.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 9: Transitive Closure</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Transitive Closure using Floyd Warshall Algorithm</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to find
                <a
                  href="https://iq.opengenus.org/transitive-closure-using-floyd-warshall-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >transitive closure using Floyd Warshall Algorithm</a
                >. The Floyd Warshall algorithm computes the shortest path
                between all pairs of vertices in a graph. By modifying the
                algorithm to compute boolean values instead of distances, we can
                use it to find the transitive closure of a graph, which
                indicates whether there is a path between every pair of
                vertices.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Transitive Closure using Graph Powering
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/transitive-closure-graph-powering/"
                  target="_blank"
                  rel="noopener"
                  >Transitive Closure using Graph Powering</a
                >
                explains how to find the transitive closure of a graph. In this
                method, the transitive closure matrix is computed iteratively by
                raising the adjacency matrix of the graph to increasingly higher
                powers.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 9: Travelling Salesman Problem</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Travelling Salesman Problem - Brute Force</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/travelling-salesman-problem-brute-force/"
                  target="_blank"
                  rel="noopener"
                  >Travelling Salesman Problem - Brute Force</a
                >
                explains one of the simplest approaches for finding the shortest
                possible route that visits every city on a given list exactly
                once and returns to the starting city. The brute force algorithm
                involves generating all possible permutations of the cities and
                calculating the distance of each permutation.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Travelling Salesman Problem - Branch and Bound
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/travelling-salesman-branch-bound/"
                  target="_blank"
                  rel="noopener"
                  >Travelling Salesman Problem - Branch and Bound</a
                >
                explains an optimization algorithm for solving the Travelling
                Salesman Problem. The Branch and Bound algorithm uses a tree
                structure to explore the possible solutions to the problem,
                pruning branches that cannot possibly lead to the optimal
                solution. This algorithm is more efficient and can handle larger
                sets of cities.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Travelling Salesman Problem - Dynamic Programming</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/travelling-salesman-problem-dp/"
                  target="_blank"
                  rel="noopener"
                  >Travelling Salesman Problem - Dynamic Programming</a
                >
                explains another optimization algorithm for solving the
                Travelling Salesman Problem. The Dynamic Programming algorithm
                works by breaking down the problem into smaller sub-problems and
                solving them recursively.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Travelling Salesman Problem - Approximation Algorithm
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/approximation-algorithm-for-travelling-salesman-problem/"
                  target="_blank"
                  rel="noopener"
                  >Travelling Salesman Problem - Approximation algorithm</a
                >
                uses the concept of Minimum Spanning Tree to solve this problem.
                This approach involves finding the best way to connect the
                cities, creating a circle that goes through all the cities and
                finding the shortest way to do so
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 10: Islands in a Grid</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Making a Large Island </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Explore the problem of
                <a
                  href="https://iq.opengenus.org/making-a-large-island/"
                  target="_blank"
                  rel="noopener"
                  >making a large island</a
                >
                by changing the value of some 0s to 1s in a given matrix.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Maximum Area of Island </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/maximum-area-of-island/"
                  target="_blank"
                  rel="noopener"
                  >Maximum Area of Island</a
                >
                is a common problem in computer science where you need to find
                the largest connected group of 1's in a grid of 1's and 0's.
                This problem can be solved using techniques such as depth-first
                search or breadth-first search.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Number of Islands </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn about the problem of finding the
                <a
                  href="https://iq.opengenus.org/number-of-islands/"
                  target="_blank"
                  rel="noopener"
                  >number of islands in a given matrix</a
                >, where an island is a group of connected 1s (representing
                land) surrounded by 0s (representing water). Explore two
                approaches to solve this problem: depth-first search (DFS) and
                breadth-first search (BFS).
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Number of Closed Islands
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Explore the
                <a
                  href="https://iq.opengenus.org/number-of-closed-islands/"
                  target="_blank"
                  rel="noopener"
                  >Number of Closed Islands</a
                >
                article that explains an algorithm to determine the number of
                isolated regions within a binary matrix where 0 represents water
                and 1 represents land.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 11: Other Graph Theory Algorithms</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Cycle in Graphs using Degree of Nodes</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                In
                <a
                  href="https://iq.opengenus.org/cycle-using-degree-of-nodes-graph/"
                  target="_blank"
                  rel="noopener"
                  >Cycle using Degree of Nodes in a Graph</a
                >, you'll learn how to detect cycles in a graph using the degree
                of nodes.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Fleury Algorithm: Finding Eulerian Tours in a Graph
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/fleury-algorithm-finding-eulerian-tours-in-a-graph/"
                  target="_blank"
                  rel="noopener"
                  >Fleury Algorithm: Finding Eulerian Tours in a Graph</a
                >
                introduces the Fleury algorithm, which finds an Eulerian tour in
                a graph. Eulerian tour is a path in a graph that visits every
                edge exactly once and returns to its starting point.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Hamiltonian Path and Cycle</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn about
                <a
                  href="https://iq.opengenus.org/hamiltonian-path/"
                  target="_blank"
                  rel="noopener"
                  >Hamiltonian Path</a
                >
                and
                <a
                  href="https://iq.opengenus.org/hamiltonian-cycle/"
                  target="_blank"
                  rel="noopener"
                  >Hamiltonian Cycle</a
                >
                and explore algorithms to find them.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Vertex Cover Problem</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/vertex-cover-problem/"
                  target="_blank"
                  rel="noopener"
                  >Vertex Cover Problem</a
                >
                explains how to find the smallest set of vertices that covers
                all edges in a graph.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Clique in Graphs</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/clique-in-graphs/"
                  target="_blank"
                  rel="noopener"
                  >Clique in Graphs</a
                >
                are a subset of vertices where every vertex is connected to
                every other vertex in the subset. Learn about the basics of
                cliques, including properties, types and algorithms for finding
                cliques in a graph, such as brute force, Bron-Kerbosch
                algorithm, and cliquer algorithm. Explore some applications of
                cliques, such as in social networks, gene expression networks,
                and computational biology.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Bron-Kerbosch Algorithm</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/bron-kerbosch-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Bron-Kerbosch algorithm</a
                >
                is a recursive algorithm for finding all maximal cliques in an
                undirected graph. The algorithm works by selecting a pivot
                vertex and iterating through all possible combinations of
                vertices that are adjacent to the pivot, checking whether each
                combination forms a clique, and recursively calling the
                algorithm on the remaining vertices.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Algorithm to Find Cliques of a Given Size k</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/algorithm-to-find-cliques-of-a-given-size-k/"
                  target="_blank"
                  rel="noopener"
                  >find all cliques of a given size k</a
                >
                in an undirected graph. The algorithm is based on the
                Bron-Kerbosch algorithm, and it involves iterating through all
                possible subsets of vertices, checking whether each subset forms
                a clique of size k, and keeping track of all such cliques.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Greedy Approach to Find Single Maximal Clique</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Explore
                <a
                  href="https://iq.opengenus.org/greedy-approach-to-find-single-maximal-clique/"
                  target="_blank"
                  rel="noopener"
                >
                  a greedy algorithm for finding a single maximal clique</a
                >
                in an undirected graph. The algorithm starts with a random
                vertex and iteratively adds adjacent vertices to the clique
                until no more vertices can be added.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Farach-Colton and Bender Algorithm (LCA)
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/farach-colton-and-bender-algorithm-lca/"
                  target="_blank"
                  rel="noopener"
                  >Farach-Colton and Bender Algorithm (LCA)</a
                >
                describes the Farach-Colton and Bender algorithm, which can be
                used to solve the lowest common ancestor problem in trees.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Mother Vertex in Graph </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/mother-vertex-in-graph/"
                  target="_blank"
                  rel="noopener"
                  >Mother Vertex in Graph</a
                >
                explains how to find a vertex that can reach all other vertices
                in a directed graph, using Tarjan's algorithm which involves
                identifying strongly connected components.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Number of Paths with K Edges
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/number-of-paths-with-k-edges/"
                  target="_blank"
                  rel="noopener"
                  >Number of Paths with K Edges</a
                >
                explains how to count the number of paths in a graph with a
                fixed number of edges, using dynamic programming to build a
                matrix of counts for each pair of vertices and number of edges.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Fundamentals of Euler Path
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                In
                <a
                  href="https://iq.opengenus.org/fundamentals-of-euler-path/"
                  target="_blank"
                  rel="noopener"
                  >Fundamentals of Euler Path</a
                >, understand the concepts and properties of Euler paths and
                circuits in graphs, including the conditions for their existence
                and how to construct them.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Transpose Graph </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to create the
                <a
                  href="https://iq.opengenus.org/transpose-graph/"
                  target="_blank"
                  rel="noopener"
                  >transpose of a graph</a
                >, which is a new graph with all the edges reversed, using an
                adjacency matrix or an adjacency list.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Find All Bridges in Graph
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/find-all-bridges-in-graph/"
                  target="_blank"
                  rel="noopener"
                  >find all the bridges in an undirected graph</a
                >, which are edges whose removal would disconnect the graph,
                using Tarjan's algorithm and depth-first search.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Karp's Minimum Mean Cycle Algorithm
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/karp-minimum-mean-cycle-algorithm/"
                  target="_blank"
                  rel="noopener"
                  >Karp's Minimum Mean Cycle Algorithm</a
                >
                first finds the shortest paths to all vertices using
                Bellman-Ford, and then iteratively adds edges to the graph to
                find the minimum mean weight cycle. The mean weight of a cycle
                is the sum of the weights of the edges in the cycle divided by
                the number of edges. The minimum mean weight cycle is the cycle
                with the smallest mean weight in the graph. It is useful in
                various applications such as transportation and logistics.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Detect Cycle in an Undirected Graph
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/detect-cycle-in-undirected-graph/"
                  target="_blank"
                  rel="noopener"
                  >detect cycles in an undirected graph</a
                >
                using Depth First Search (DFS) algorithm and the disjoint-set
                data structure.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Biconnected Graph </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/biconnected-graph/"
                  target="_blank"
                  rel="noopener"
                  >Biconnected Graph</a
                >
                is a connected graph that remains connected even after any
                vertex (or node) is removed. The article explains the concepts
                of biconnected components and biconnected graphs and presents
                algorithms for finding them.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Entropy of Graph </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/entropy-of-graph/"
                  target="_blank"
                  rel="noopener"
                  >Entropy of Graph</a
                >
                explains how to calculate the entropy of a graph, which measures
                the degree of randomness or uncertainty in the graph, using
                information theory.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Biconnected Components </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/biconnected-components/"
                  target="_blank"
                  rel="noopener"
                  >Biconnected Components</a
                >
                article explains an algorithm used in graph theory to identify
                the set of edges that would remain if any single vertex was
                removed from the graph.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">Week 12: Other Tree based Problems</h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Centroid Decomposition of Tree</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                In
                <a
                  href="https://iq.opengenus.org/centroid-decomposition-of-tree/"
                  target="_blank"
                  rel="noopener"
                  >Centroid Decomposition of Tree</a
                >
                a tree is recursively divided into smaller subtrees by finding
                its centroid (i.e., the node that minimizes the maximum subtree
                size), and each subtree is processed separately. We can use this
                to solve tree based problems like finding the diameter of a
                tree, computing the distance between two nodes etc.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Diameter using Height of Node
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/diameter-using-height-of-node/"
                  target="_blank"
                  rel="noopener"
                  >Diameter Using Height of Node</a
                >
                article explains how to find the diameter of a tree using the
                height of its nodes, by computing the heights of each node and
                finding the pair of nodes with the maximum distance between
                them.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Diameter of n-ary Tree (DP)</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/diameter-of-n-ary-tree-dp/"
                  target="_blank"
                  rel="noopener"
                  >Diameter of n-ary Tree (DP)</a
                >
                article explains how to find the diameter of an n-ary tree using
                dynamic programming. An n-ary tree is a tree data structure in
                which each node can have at most n children.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Ancestors of Node in Binary Tree
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to find
                <a
                  href="https://iq.opengenus.org/ancestors-of-node-in-binary-tree/"
                  target="_blank"
                  rel="noopener"
                  >Ancestors of Node in Binary Tree</a
                >
                using iterative and
                <a
                  href="https://iq.opengenus.org/ancestors-of-node-in-binary-tree-recursive/"
                  target="_blank"
                  rel="noopener"
                  >recursive</a
                >
                approaches.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Nodes which are at distance K from root
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/nodes-which-are-at-distance-k-from-root/"
                  target="_blank"
                  rel="noopener"
                  >Nodes which are at distance K from root</a
                >
                article explains how to find all nodes in a binary tree that are
                at a distance of K from the root node, using a simple
                depth-first search approach and maintaining the level of each
                node in the tree.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Nodes at Distance K from Given Node
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to find all
                <a
                  href="https://iq.opengenus.org/nodes-at-distance-k-from-given-node/"
                  target="_blank"
                  rel="noopener"
                  >nodes in a binary tree that are at a distance of K from a
                  given node</a
                >
                , using a combination of depth-first search and breadth-first
                search. The algorithm first finds the target node and then
                performs a breadth-first search to find all nodes at a distance
                of K from it.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Minimum Nodes Removed (No Subtree More than K Nodes)
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to find
                <a
                  href="https://iq.opengenus.org/minimum-nodes-removed-no-subtree-more-than-k-nodes/"
                  target="_blank"
                  rel="noopener"
                  >the minimum number of nodes that need to be removed from a
                  tree</a
                >
                in order to ensure that no subtree in the resulting tree has
                more than K nodes. The algorithm recursively computes the size
                of each subtree and performs a post-order traversal to mark the
                nodes that need to be removed. Traversal begins first the left
                subtree, then the right subtree, and finally the root node.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Maximum Sum Leaf to Root Path
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/maximum-sum-leaf-to-root-path/"
                  target="_blank"
                  rel="noopener"
                  >Maximum Sum Leaf to Root Path</a
                >
                article discusses an algorithm for finding the maximum sum
                leaf-to-root path in a binary tree, which is the path with the
                highest sum of node values from any leaf node to the root node.
                A "leaf node" refers to a node in a tree data structure that
                does not have any branches or sub-nodes stemming from it.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Find Height or Depth of Binary Tree</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Explore how to
                <a
                  href="https://iq.opengenus.org/find-height-or-depth-of-binary-tree/"
                  target="_blank"
                  rel="noopener"
                  >find height or depth of Binary Tree</a
                >
                using an algorithm to find the height or depth of a binary tree,
                a tree data structure where each node has at most two child
                nodes.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Minimum Number of Swaps Required to Convert Binary Tree to Binary
              Search Tree
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/algorithm-for-finding-minimum-number-of-swaps-required-to-convert-binary-tree-to-binary-search-tree/"
                  target="_blank"
                  rel="noopener"
                  >Minimum Number of Swaps Required to Convert Binary Tree to
                  Binary Search Tree</a
                >
                explains an algorithm that converts a binary tree into a binary
                search tree with minimum swaps, using a combination of in-order
                traversal and a modified selection sort.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Find Level of Node from Root
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/find-level-of-node-from-root/"
                  target="_blank"
                  rel="noopener"
                  >find the level or depth of a node</a
                >
                in a binary tree from the root node using recursion and
                depth-first search.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Find Maximum or Minimum Element in Binary Search Tree
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn how to
                <a
                  href="https://iq.opengenus.org/find-maximum-or-minimum-element-in-binary-search-tree/"
                  target="_blank"
                  rel="noopener"
                  >find maximum or minimum element in Binary Search Tree</a
                >
                using an algorithm used to find the maximum or minimum element
                in a binary search tree, a data structure that allows for
                efficient searching, insertion, and deletion operations.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">
          Week 13.a: Other Graph Traversal Algorithms
        </h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Depth Limited Search</span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/depth-limited-search/"
                  target="_blank"
                  rel="noopener"
                  >Depth Limited Search</a
                >
                is a variant of depth-first search where a maximum depth limit
                is set for the search. This is useful in cases where we don't
                want the search to go too deep and want to limit the amount of
                resources used by the search algorithm.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Iterative Deepening Search</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/iterative-deepening-search/"
                  target="_blank"
                  rel="noopener"
                  >Iterative Deepening Search</a
                >
                is a search algorithm that combines the benefits of both
                depth-first search and breadth-first search. It starts with a
                depth limit of 0 and gradually increases the depth limit until
                the goal is found. This algorithm is useful in cases where the
                search space is large and the depth of the solution is unknown.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Iterative Inorder Traversal
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/iterative-inorder-travesal/"
                  target="_blank"
                  rel="noopener"
                  >Iterative Inorder Traversal</a
                >
                is a method for traversing a binary tree in an inorder fashion
                (i.e., visiting the left subtree, then the root, then the right
                subtree) without using recursion. It uses a stack data structure
                to simulate the recursive calls used in the recursive version of
                the inorder traversal algorithm.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">
          Week 13.b: Miscellaneous Graph Theory Problems
        </h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Alien Dictionary </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Understand how to create an
                <a
                  href="https://iq.opengenus.org/alien-dictionary/"
                  target="_blank"
                  rel="noopener"
                  >alien dictionary</a
                >
                given a list of words in a specific order. It presents an
                approach to solve this problem using topological sorting, which
                is a technique used to order the vertices in a directed graph.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">De Bruijn Sequences </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/de-brujin-sequences/"
                  target="_blank"
                  rel="noopener"
                  >De Bruijn Sequences</a
                >
                are special sequences that contain every possible k-length
                sequence of a given alphabet exactly once as a substring. They
                have applications in various fields such as coding theory,
                cryptography, and bioinformatics.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Graph and Subgraph Isomorphism
            </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/graph-and-subgraph-isomorphism/"
                  target="_blank"
                  rel="noopener"
                  >Graph and Subgraph Isomorphism</a
                >
                is the problem of determining whether a given graph contains a
                subgraph that is structurally identical to a given graph. It is
                an important problem in computer science and has applications in
                various fields such as chemistry, biology, and computer vision.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">
          Week 13.c: Graph Data Structure using Java
        </h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">Graph using OOP in Java </span>
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/graph-using-oop-java/"
                  target="_blank"
                  rel="noopener"
                  >Graph using OOP Java</a
                >
                tutorial explains how to implement a graph data structure using
                object-oriented programming principles in Java, a popular
                programming language.
              </div>
            </div>
          </li>
        </ul>
      </section>

      <section class="checklist">
        <h2 class="checklist__title">
          Week 13.d: Applications of Graph in Real life
        </h2>
        <span class="checklist__title-border"></span>
        <span class="checklist__percentage-border"></span>
        <ul class="checklist-container">
          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Algorithm Behind Bill Splitting App</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn about the
                <a
                  href="https://iq.opengenus.org/algorithm-behind-bill-splitting-app/"
                  target="_blank"
                  rel="noopener"
                  >algorithm behind Bill Splitting App</a
                >
                which involves dividing bills among friends based on their
                respective shares, and ensuring that everyone pays and receives
                the correct amount.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title"
              >Two Sum Problem in Binary Search Tree</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                <a
                  href="https://iq.opengenus.org/two-sum-problem-in-binary-search-tree/"
                  target="_blank"
                  rel="noopener"
                  >Two Sum Problem in Binary Search Tree</a
                >
                explains how to solve the two sum problem for a binary search
                tree, which involves finding two nodes in the tree that add up
                to a given target value. Learn a simple recursive approach that
                utilizes the properties of binary search trees to achieve linear
                time complexity. This problem is applicable in real-life
                scenarios such as financial transactions, data analysis,
                engineering, and image processing.
              </div>
            </div>
          </li>

          <li class="checklist-item">
            <input id="" type="checkbox" /><label
              for=""
              class="checkbox"
            ></label
            ><span class="checklist-item__title">
              Use of Graph data structure in TensorFlow</span
            >
            <button
              class="checklist-item__expand"
              aria-label="Toggle Info"
              title="Toggle More Information"
            >
              <span class="line"></span>
            </button>
            <div class="info-container">
              <div class="info">
                Learn about the
                <a
                  href="https://iq.opengenus.org/two-sum-problem-in-binary-search-tree/"
                  target="_blank"
                  rel="noopener"
                  >applications of Graph in TensorFlow</a
                >. Tensorflow is an open-source machine learning framework that
                uses a computation graph to represent a machine learning or deep
                learning model, with each node in the graph representing an
                operation and each edge representing the flow of data between
                these operations.
              </div>
            </div>
          </li>
        </ul>
      </section>
    </div>

    <script src="./assets/js/checklist/checklist-track.js"></script>
    <h3 class="text_end">Best of Luck.</h3>
    <p class="text_end">Powered by OpenGenus IQ because we love ❤️ you.</p>
    <br /><br />
  </body>
</html>
