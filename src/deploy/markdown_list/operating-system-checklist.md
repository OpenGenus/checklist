# Operating System Checklist

Only concepts that you need to review to ace your Interview

**Types & Variants: -**
===================
1. **Evolution of Operating systems**<br>  
2. **Types of Operating Systems**<br>  An operating system ( OS) is system software that manages computer hardware and software resources, and provides common services for computer programs .
        Operating Systems have evolved in past years. It went through several changes before getting its original form. These changes in the operating system are known as the [evolution of operating systems](#)
3. **Distributed Operating System**<br>  A [distributed operating system](https://iq.opengenus.org/distributed-operating-system/) is a concept in which distributed programs operate on several machines that are linked together via communications. But it has its 
      [challenges ](https://iq.opengenus.org/challenges-failures-in-distributed-systems/) too.
4. **GNU/Linux**<br>  Linux or [GNU/Linux](https://iq.opengenus.org/gnu-linux/) is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds. Linux is typically packaged as a Linux distribution (distro), which includes the kernel and supporting system software and libraries, many of which are provided by the GNU Project.
5. **Android**<br>  [Android](https://iq.opengenus.org/architecture-of-android-os/) is a mobile operating system based on a modified version of the Linux kernel and other open-source software, designed for touchscreen devices such as smartphones and tablets. It is developed by a consortium of developers known as the Open Handset Alliance, mostly by Google.
6. **Inter-Process Communication**<br>  [Inter-process communication (IPC)](https://iq.opengenus.org/interprocess-communication-and-types-in-os/) helps to achieve the communication among the processes or threads in a system.
7. **APIs**<br>  An [application programming interface ( API)]()  is a way for two or more computer programs to communicate with each other.
8. **Types of System Call Methods**<br>  [System](#) calls are interfaces provisioned by the operating system to allow user-level applications to interact with low-level hardware components & make use of all the services provided by the kernel, which is a core component and the heart of an operating system that manages all the hardware and the services provided by the OS.
9. **I/O Device controllers**<br>  [I/O Controllers](#)are a series of microchips which help in the communication of data between the central processing unit and the motherboard. The main purpose of this system is to help in the interaction of peripheral devices with the control units (CUs)
10. **Scheduling & Spooling**<br>  [CPU Scheduling](#) is a process that allows one process to use the CPU while another process is delayed (in standby) due to unavailability of any resources such as I / O etc, thus making full use of the CPU.
      [Spooling](#) is the process of temporary storage of data for use and execution by a device, program, or system. Data is sent to and stored in main memory or other volatile storage until it is requested for execution by a program or computer.
11. **Operations & Buffering**<br>  [Input/output operations](#) are the communications between an information processing system, such as a computer, and the outside world, possibly a human or another information processing system. 
     [Buffering](#) is a technique which is used to enhance the performance of I/O operations of the system. Basically, buffering in operating system is a method of storing data in a buffer or cache temporarily, this buffered data then can be accessed more quickly as compared to the original source of the data.
12. **Interrupt Handling**<br>  [Interrupt handling](#) refers to the process by which a computer system or program responds to an interrupt signal. An interrupt is a signal that indicates an event or condition that requires immediate attention from the processor. This can be triggered by hardware devices such as timers, I/O devices, or errors, as well as software-generated interrupts.
13. **File Concepts & Operations**<br>  [File concepts and operations](#) refer to the principles and actions involved in working with files on a computer system. 

         A file is a named collection of related information that is stored on a storage device, such as a hard drive or SSD. Files can contain various types of data, including text, images, audio, video, and more.

        File operations involve tasks such as creating, opening, reading, writing, modifying, deleting, and closing files. These operations are performed by the operating system or applications to manage and manipulate file contents.
14. **File Organization & Accessing**<br>  [File organization](#) refers to the way in which files are structured and stored on a storage device. It involves determining how data is arranged within a file and how files are organized within a file system.
      [Accessing](#) files refers to the process of retrieving or manipulating data stored within a file
15. **File System Implementations**<br>  A [file system](#) is a method an operating system uses to store, organize, and manage files and directories on a storage
16. **Disk Scheduling Algorithms**<br>  [Disk Scheduling Algorithms](#) in an operating system can be referred to as a manager of a grocery store that manages all the incoming and outgoing requests for goods of that store. He keeps a record of what is available in-store, what we need further, and manages the timetable of transaction of goods.
17. **BIOS**<br>  [BIOS](https://iq.opengenus.org/bios/) - firmware stored in non-volatile memory e.g EPROM, responsible for performing startup procedures such as POST before passing control to the bootloader which loads the OS.
18. **UEFI & Legacy**<br>  [UEFI & Legacy](https://iq.opengenus.org/uefi-and-legacy-boot/) are firmware that specifies an interface between the computer operating system and the underlying firmware. Legacy boot involves booting the computer using legacy firmware such as BIOS and UEFI boot involves booting a computer using the more advanced UEFI.
19. **Secure Boot**<br>  [Secure Boot](https://iq.opengenus.org/secure-boot/) is a security standard implemented in the advanced UEFI to prevent malware from attacking the computer during bootup when the computer is most vulnerable.
20. **Threats & Vulnerabilities**<br>  [Threats and vulnerabilities](#) in an operating system (OS) refer to potential risks or weaknesses that can be exploited by malicious actors or result in unintended consequences. These threats and vulnerabilities can compromise the security, stability, and functionality of the OS.
21. **Security Policies & Enforcement**<br>  [Security policies and enforcements](#) in an Operating System (OS) refer to the rules and mechanisms put in place to protect the system from unauthorized access, ensure data confidentiality and integrity, and mitigate potential security threats. These policies are typically enforced by the OS through various security mechanisms.
22. **Encryption & Cryptography**<br>  [Encryption](#) refers to the process of converting plain, readable data into an encoded or encrypted form. The purpose of encryption is to ensure that even if the data is intercepted or accessed by unauthorized users, it remains unintelligible and can only be deciphered with the appropriate decryption key.
[Cryptography](#) involves techniques, protocols, and mathematical algorithms that secure communication, prevent unauthorized access, and protect confidentiality, integrity, and authenticity of data. It includes encryption, decryption, digital signatures, key management, and various cryptographic protocols.
23. **Linux Memory Management**<br>  Learn about [how memory is managed in linux](https://iq.opengenus.org/linux-memory-management/)
24. **Process control block**<br>  A [process control block (PCB)](#) is a data structure used by computer operating systems to store all the information about a process. It specifies and tracks the process state, scheduling, control, and resources.
25. **Context-Switching**<br>  [Context Switching](https://iq.opengenus.org/context-switching-in-os/) helps store the context of a process, thread, or state, which can be accessed at the same point when reloaded.
It allows multiple processes to share the same CPU at a single given point of time, making it a multitasking feature.
26. **Memory Allocation Strategy fits**<br>  To gain proper memory utilization, memory allocation must be allocated or [fitted](https://iq.opengenus.org/first-best-and-worst-fit-strategies/) efficient manner. One of the simplest methods for allocating memory is to divide memory into several fixed-sized partitions
27. **Scheduling Algorithms**<br>  [CPU Scheduling algorithm](https://iq.opengenus.org/types-of-cpu-scheduling-algorithms/) is an algorithm which is used to assign system resources to processes in a computing system.
28. **Round Robin Algorithm**<br>  [Round Robin Scheduling Algorithm ](https://iq.opengenus.org/round-robin-scheduling/)is one of the simplest scheduling algorithm used in various operating systems for process scheduling and networks. The key idea is to allocate CPU to all processes in the same order for the same amount of time.
29. **Shortest Job First(SJF)**<br>  [Shortest Job First (SJF)](https://iq.opengenus.org/round-robin-scheduling/) CPU scheduling algorithm is a CPU scheduling algorithm which is based on the principles of Greedy Algorithms. The key idea is to allocate the CPU to the process with the smallest burst time so that the CPU seems to be more responsive. Burst time is the amount of time required by a process for its execution on the CPU.
30. **Mutex & Critical Section**<br>  Learn more about[Mutex & Critical Section](https://iq.opengenus.org/mutex-and-critical-section/) in resource management.
31. **Lock Convoy Problem**<br>  A[ lock convoy](https://iq.opengenus.org/lock-convoy-problem/) is a performance problem that can occur when using locks for concurrency control in a multithreaded application.
32. **Producer Consumer Problem**<br>  The [producer-consumer problem](#) is an example of a multi-process synchronization problem. The problem describes two processes, the producer and the consumer that shares a common fixed-size buffer use it as a queue.
33. **Dining Philisophers' Problem**<br>  The [dining philosophers problem](#) is an example problem often used in concurrent algorithm design to illustrate synchronization issues and techniques for resolving them
34. **Readers Writers Problem**<br>  The [Readers-Writers Problem](#) is a classic synchronization and concurrency problem in computer science and operating system design. It arises when there is a shared resource that can be read by multiple processes (readers) but only written by one process (writer) at a time.
35. **Sleeping Barber Problem**<br>  The[ Sleeping Barber Problem](https://iq.opengenus.org/sleeping-barber-problem/) is a synchronization problem in computer science that deals with the management of a shared resource by multiple processes.
36. **Learn more about Virtualization**<br>  Add description.
37. **Hypervisors**<br>  A [hypervisor](#) is a type of computer software, firmware or hardware that creates and runs virtual machines. A computer on which a [hypervisor](#) runs one or more virtual machines is called a host machine, and each virtual machine is called a guest machine.
38. **QEMU & KVMs**<br>  [QEMU](#) is a free and open-source emulator. It emulates a computer's processor through dynamic binary translation and provides a set of different hardware and device models for the machine, enabling it to run a variety of guest operating systems
[Kernel-based Virtual Machine (KVM)](#) is a free and open-source virtualization module in the Linux kernel that allows the kernel to function as a hypervisor. It was merged into the mainline Linux kernel in version 2.6.20, which was released on February 5, 2007.
39. **VM Management**<br>  [VM management](#), also known as virtual machine management, refers to the process of managing and administering virtual machines (VMs) within a virtualization environment. Virtual machines are software emulations of physical computers that enable multiple operating systems to run concurrently on a single physical machine.
40. **Storage & Networking**<br>  [Storage](#) in VM refers to the allocation and management of disk space for storing data and operating system files. It is required for installing and running applications within the VM. 
[Networking](#) in VM involves connecting VMs to each other and to external networks, enabling communication and sharing of resources.
41. **Virtualization Security**<br>  [Security]() in virtualization refers to the measures and practices implemented to protect virtualized environments and the data and resources within them. Virtualization allows multiple virtual machines (VMs) to run on a single physical server, which introduces unique security considerations.

---
Generated by OpenGenus. Updated on 2024-05-31